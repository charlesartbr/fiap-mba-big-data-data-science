# -*- coding: utf-8 -*-
"""OLSR e Ensemble Methods.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fLs5bbJ3_9RzVXCBKnRKxIwTbs7MGevZ
"""

import pandas as pd
import numpy as np
import matplotlib as plt

from google.colab import files
uploaded = files.upload()

df = pd.read_csv('Arquivo-Treino.csv')
df.head()

# A função describe() fornece contagem, média, desvio padrão (STD), mínimo, quartis e máximo
df.describe()

# Análise de dados não continuos
df['Property_Area'].value_counts()

# Análise de Distribuição 
df['ApplicantIncome'].hist(bins=50)

# Isso confirma a presença de uma grande quantidade de outliers/valores extremos. 
# Isso pode ser atribuído à disparidade de renda na sociedade. 
# Parte disso pode ser impulsionado pelo fato de que nós estamos olhando para as pessoas com diferentes níveis de ensino. 
# Vamos segregá-los por Educação:
df.boxplot(column='ApplicantIncome')

# Análise de dados não continuos
df.boxplot(column='ApplicantIncome', by='Education')

# Análise de Distribuição 
df['LoanAmount'].hist(bins=50)

df.boxplot(column='LoanAmount')

temp1 = df['Credit_History'].value_counts(ascending=True)
temp2 = df.pivot_table(values='Loan_Status', index=['Credit_History'], aggfunc=lambda x: x.map({ 'Y': 1, 'N': 0 }).mean())
print('Frequency Table for Credit History:')
print(temp1)
print('\nProbability of getting loan for each Credit History class:')
print(temp2)

# Análise de Variáveis Categóricas: Queremos uma tabala dinâmica, mas não estamos no Excel
import matplotlib.pyplot as plt
temp3 = pd.crosstab(df['Credit_History'], df['Loan_Status']) 
temp3.plot(kind='bar', stacked=True, color=['red','blue'], grid=False)

# Verificando os Valores Ausentes no Conjunto de Dados
df.apply(lambda x: sum(x.isnull()), axis=0)

# Como preencher valores ausentes? Exemplo campo LoanAmount, valor do empréstimo.
df['LoanAmount'].fillna(df['LoanAmount'].mean(), inplace=True)
df.apply(lambda x: sum(x.isnull()), axis=0)

# Self_Employed tem alguns valores ausentes
df['Self_Employed'].value_counts()

# Como 86% dos valores são “não”, é seguro calcular os valores ausentes como “Não” pois há uma alta probabilidade de sucesso
df['Self_Employed'].fillna('No', inplace=True)
df.apply(lambda x: sum(x.isnull()), axis=0)

# Agora, vamos criar uma tabela dinâmica que nos forneça valores médios para todos os grupos de valores exclusivos 
# de características de Self_Employed e Educação. Em seguida, vamos definir uma função, que retorna os valores dessas 
# células e aplicá-los para preencher os valores ausentes de valor do empréstimo:
table = df.pivot_table(values='LoanAmount', index='Self_Employed', columns='Education', aggfunc=np.median)
table

# Define a função que retorna o valor da tabela pivot 
def fage(x):
   return table.loc[x['Self_Employed'], x['Education']] # Substitui valores faltantes
   df['LoanAmount'].fillna(df[df['LoanAmount'].isnull()].apply(fage, axis=1), inplace=True)

# Como tratar valores extremos na distribuição de valor do empréstimo (LoanAmount) e Solicitante de renda (ApplicantIncome)?
df['LoanAmount_log'] = np.log(df['LoanAmount']) 
df['LoanAmount_log'].hist(bins=20)

# Construção de um Modelo Preditivo

# Após tornarmos os dados úteis para a modelagem, vamos criar um modelo preditivo em nosso conjunto de dados. 
# Scikit-learn (sklearn) é a biblioteca mais comumente usada em Python para este fim e vamos seguir a trilha

# Uma vez que sklearn exige que todas as entradas estejam numéricas, devemos converter todas as variáveis 
# categóricas em numéricas através da codificação das categorias

df['Gender'].fillna(df['Gender'].mode()[0], inplace=True)
df['Married'].fillna(df['Married'].mode()[0], inplace=True)
df['Dependents'].fillna(df['Dependents'].mode()[0], inplace=True)
df['Loan_Amount_Term'].fillna(df['Loan_Amount_Term'].mode()[0], inplace=True)
df['Credit_History'].fillna(df['Credit_History'].mode()[0], inplace=True)

from sklearn.preprocessing import LabelEncoder 

var_mod =['Gender','Married','Dependents','Education','Self_Employed','Property_Area','Loan_Status'] 
le = LabelEncoder() 

for i in var_mod: 
  df[i] = le.fit_transform(df[i]) 

df.dtypes

df

# Preço de imóveis em Boston OLSR-Regressão
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.datasets import load_boston

boston = load_boston()
model = LinearRegression().fit(boston['data'], boston['target'])

print(model.intercept_)
print(model.coef_)

y_predicted = model.predict(boston['data'])

rmse = mean_squared_error(boston['target'], y_predicted)
r2 = r2_score(boston['target'], y_predicted)

print(rmse)
print(r2)
print('Mean Absolute Error:', mean_absolute_error(boston['target'], y_predicted))

import numpy as np

df1 = pd.DataFrame(data = np.c_[boston['target'], y_predicted], columns = ['real', 'predicted'])
df1.head()